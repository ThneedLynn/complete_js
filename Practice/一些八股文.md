### JS 小问题

### Object constructor

> `{...}` snytax let us create one object. Why need constructor(new operator)? 

To implement reusable object creation code. That can be done using constructor functions and the "new" operator. 

Now if we want to create other users, we can call new User("Ann"), new User("Alice") and so on. Much shorter than using literals every time, and also easy to read.

### Constructor vs regular function

constructor technically are regular functions. Two conventions: 
1. named with capital letter first
2. should be executed only with "new" operator

Technically, any function (except arrow functions, as they don’t have this) can be used as a constructor. It can be run with new, and it will execute the algorithm above. (The “capital letter first” is a common agreement, to make it clear that a function is to be run with new.)

### What happened when a function is called with "new" operator

1. this = {};
2. function body executed. Usually it modifies this, adds new properties 
3. value of "this" is returned

```js
function User(name) {
  // this = {};  (implicitly)

  // add properties to this
  this.name = name;
  this.isAdmin = false;

  // return this;  (implicitly)
}
let user = new User("Jack");
// user = {
//   name: "Jack",
//   isAdmin: false
// };

```

### 一次性constructor (encapsulate the code )
This constructor can’t be called again, because it is not saved anywhere, just created and called.

```js
// create a function and immediately call it with new
let user = new function() {
  this.name = "John";
  this.isAdmin = false;
};
```

### constructor mode test
怎么判断一个function is called with "new", in construction mode / without "new", regular mode? 

```js
function User() {
  alert(new.target);
}

// without "new":
User(); // undefined

// with "new":
new User(); // function User { ... }
```

### 都转换成constructor call
```js
function User(name) {
  if (!new.target) { // if you run me without new
    return new User(name); // ...I will add new for you
  }

  this.name = name;
}

let john = User("John"); // redirects call to new User
alert(john.name); // John
```

### return in constructor

- If return is called with an object, then the object is returned instead of this.
- If return is called with a primitive, it’s ignored.


### Object keys: String vs Symbol: What’s the benefit of using Symbol("id") over a string "id"?
Symbols allow us to create “hidden” properties of an object, that no other part of code can accidentally access or overwrite.
Symbol cannot be auto-converted to String. 

```js
let id = Symbol("id");
alert(id.toString()); // Symbol(id), now it works
alert(id.description); // id
```
Example 1: As user objects belongs to another code, and that code also works with them, we shouldn’t just add any fields to it. That’s unsafe. But a symbol cannot be accessed accidentally, the third-party code probably won’t even see it, so it’s probably all right to do.

Example 2: Also, imagine that another script wants to have its own identifier inside user, for its own purposes. That may be another JavaScript library, so that the scripts are completely unaware of each other.

There will be no conflict between our and their identifiers, because symbols are always different, even if they have the same name. But if we used a string "id" instead of a symbol for the same purpose, then there would be a conflict.

```js 
// ...
const user = {name: "John"};
let id = Symbol("id");
user[id] = "Their id value";
```

Technically, ==symbols are not 100% hidden==. There is a built-in method Object.getOwnPropertySymbols(obj) that allows us to get all symbols. `[Symbol(id)]`

Also there is a method named Reflect.ownKeys(obj) that returns all keys of an object including symbolic ones.`['name', Symbol(id)]`

### Symbol will be skipped by for...in loop, but Object.assign copies both string and symbol properties
Object.keys(user) also ignores them. That’s a part of the general “hiding symbolic properties” principle.

```js 
let id = Symbol("id");
let user = {
  [id]: 123
};
let clone = Object.assign({}, user);
alert( clone[id] ); // 123
```

### What is global symbol registry
We can create symbols in it and access them later, and it guarantees that repeated accesses by the same name return exactly the same symbol.

That call checks the global registry, and if there’s a symbol described as key, then returns it, otherwise creates a new symbol Symbol(key) and stores it in the registry by the given key.

```js
// read from the global registry
let id = Symbol.for("id"); // if the symbol did not exist, it is created

// read it again (maybe from another part of the code)
let idAgain = Symbol.for("id");

// the same symbol
alert( id === idAgain ); // true

Symbol.keyFor(idAgain); // "id" keyFor 只对global的管用

let localSymbol = Symbol("name");
alert( localSymbol.description ); // name
```

### Object's toString and valueOf
By default, a plain object has following toString and valueOf methods:

- The toString method returns a string "[object Object]".
- The valueOf method returns the object itself.

```js
let user = {name: "John"};
alert(user); // [object Object]
alert(user.valueOf() === user); // true
```